\section{iOS Application Design Patterns}
\label{sect:cocoa}

The iOS Application Programming Guide identifies three fundamental software
design patterns that apply across all frameworks: Model-View-Controller,
Delegation, and Target-Action.

\subsection{Model-View-Controller}
\label{sect:cocoa_mvc}

\emph{This section is from the iOS Application Programming Guide
\cite[p.~160--165]{ios:cocoa-fundamentals}.}

Model-View-Controller is a high-level pattern in that it concerns itself
with the global architecture of an application and classifies objects
according to the general roles they play in an application. It is also a
compound pattern in that it comprises several, more elemental patterns.

The MVC design pattern considers there to be three types of objects: model
objects, view objects, and controller objects. The MVC pattern defines the
roles that these types of objects play in the application and their lines of
communication. When designing an application, a major step is choosing ---
or creating custom classes for --- objects that fall into one of these three
groups. Each of the three types of objects is separated from the others by
abstract boundaries and communicates with objects of the other types across
those boundaries.

\subsubsection{Model Objects Encapsulate Data and Basic Behaviors}

Model objects represent special knowledge and expertise. They hold an
application’s data and define the logic that manipulates that data. A
well-designed MVC application has all its important data encapsulated in model
objects. Any data that is part of the persistent state of the application
(whether that persistent state is stored in files or databases) should reside in
the model objects once the data is loaded into the application. Because they
represent knowledge and expertise related to a specific problem domain, they
tend to be reusable.

Ideally, a model object has no explicit connection to the user interface used to
present and edit it. For example, if you have a model object that represents a
person (say you are writing an address book), you might want to store a
birthdate. That’s a good thing to store in your Person model object. However,
storing a date format string or other information on how that date is to be
presented is probably better off somewhere else.

In practice, this separation is not always the best thing, and there is some
room for flexibility here, but in general a model object should not be concerned
with interface and presentation issues. One example where a bit of an exception
is reasonable is a drawing application that has model objects that represent the
graphics displayed. It makes sense for the graphic objects to know how to draw
themselves because the main reason for their existence is to define a visual
thing. But even in this case, the graphic objects should not rely on living in a
particular view or any view at all, and they should not be in charge of knowing
when to draw themselves. They should be asked to draw themselves by the view
object that wants to present them.

\subsubsection{View Objects Present Information to the User}

A view object knows how to display, and might allow users to edit, the data from
the application’s model. The view should not be responsible for storing the data
it is displaying. (This does not mean the view never actually stores data it’s
displaying, of course. A view can cache data or do similar tricks for
performance reasons). A view object can be in charge of displaying just one part
of a model object, or a whole model object, or even many different model
objects. Views come in many different varieties.

View objects tend to be reusable and configurable, and they provide consistency
between applications. In Cocoa, the AppKit framework defines a large number of
view objects and provides many of them in the Interface Builder library. By
reusing the AppKit’s view objects, such as \texttt{NSButton} objects, you
guarantee that buttons in your application behave just like buttons in any other
Cocoa application, assuring a high level of consistency in appearance and
behavior across applications.

A view should ensure it is displaying the model correctly. Consequently, it
usually needs to know about changes to the model. Because model objects should
not be tied to specific view objects, they need a generic way of indicating that
they have changed.

\subsubsection{Controller Objects Tie the Model to the View}

A controller object acts as the intermediary between the application's view
objects and its model objects. Controllers are often in charge of making sure
the views have access to the model objects they need to display and act as the
conduit through which views learn about changes to the model. Controller objects
can also perform set-up and coordinating tasks for an application and manage the
life cycles of other objects.

In a typical Cocoa MVC design, when users enter a value or indicate a choice
through a view object, that value or choice is communicated to a controller
object. The controller object might interpret the user input in some
application-specific way and then either may tell a model object what to do with
this input—for example, "add a new value" or "delete the current record"—or it
may have the model object reflect a changed value in one of its properties.
Based on this same user input, some controller objects might also tell a view
object to change an aspect of its appearance or behavior, such as telling a
button to disable itself. Conversely, when a model object changes—say, a new
data source is accessed—the model object usually communicates that change to a
controller object, which then requests one or more view objects to update
themselves accordingly.

Controller objects can be either reusable or nonreusable, depending on their
general type.

\subsubsection{Combining Roles}

One can merge the MVC roles played by an object, making an object, for example,
fulfill both the controller and view roles—in which case, it would be called a
view controller. In the same way, you can also have model-controller objects.
For some applications, combining roles like this is an acceptable design.

A model controller is a controller that concerns itself mostly with the model
layer. It “owns” the model; its primary responsibilities are to manage the model
and communicate with view objects. Action methods that apply to the model as a
whole are typically implemented in a model controller.

A view controller is a controller that concerns itself mostly with the view
layer. It “owns” the interface (the views); its primary responsibilities are to
manage the interface and communicate with the model. Action methods concerned
with data displayed in a view are typically implemented in a view controller. A
\texttt{UITableViewController} object (also part of the document architecture)
is an example of a view controller.

\section{iOS Development Environment}
\label{sect:ios_dev_env}
